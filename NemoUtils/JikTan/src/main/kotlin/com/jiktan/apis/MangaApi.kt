/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.jiktan.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import com.jiktan.models.EntryRecommendations
import com.jiktan.models.ExternalLinks
import com.jiktan.models.Forum
import com.jiktan.models.GetAnimeRelations200Response
import com.jiktan.models.GetMangaById200Response
import com.jiktan.models.GetMangaFullById200Response
import com.jiktan.models.MangaCharacters
import com.jiktan.models.MangaNews
import com.jiktan.models.MangaPictures
import com.jiktan.models.MangaReviews
import com.jiktan.models.MangaSearch
import com.jiktan.models.MangaSearchQueryOrderby
import com.jiktan.models.MangaSearchQueryStatus
import com.jiktan.models.MangaSearchQueryType
import com.jiktan.models.MangaStatistics
import com.jiktan.models.MangaUserupdates
import com.jiktan.models.Moreinfo
import com.jiktan.models.SearchQuerySort

import com.fasterxml.jackson.annotation.JsonProperty

import com.jiktan.infrastructure.ApiClient
import com.jiktan.infrastructure.ApiResponse
import com.jiktan.infrastructure.ClientException
import com.jiktan.infrastructure.ClientError
import com.jiktan.infrastructure.ServerException
import com.jiktan.infrastructure.ServerError
import com.jiktan.infrastructure.MultiValueMap
import com.jiktan.infrastructure.PartConfig
import com.jiktan.infrastructure.RequestConfig
import com.jiktan.infrastructure.RequestMethod
import com.jiktan.infrastructure.ResponseType
import com.jiktan.infrastructure.Success
import com.jiktan.infrastructure.toMultiValue

class MangaApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.jikan.moe/v4")
        }
    }

    /**
     * GET /manga/{id}
     *
     *
     * @param id
     * @return GetMangaById200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMangaById(id: kotlin.Int) : GetMangaById200Response {
        val localVarResponse = getMangaByIdWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetMangaById200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /manga/{id}
     *
     *
     * @param id
     * @return ApiResponse<GetMangaById200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getMangaByIdWithHttpInfo(id: kotlin.Int) : ApiResponse<GetMangaById200Response?> {
        val localVariableConfig = getMangaByIdRequestConfig(id = id)

        return request<Unit, GetMangaById200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMangaById
     *
     * @param id
     * @return RequestConfig
     */
    fun getMangaByIdRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/manga/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /manga/{id}/characters
     *
     *
     * @param id
     * @return MangaCharacters
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMangaCharacters(id: kotlin.Int) : MangaCharacters {
        val localVarResponse = getMangaCharactersWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MangaCharacters
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /manga/{id}/characters
     *
     *
     * @param id
     * @return ApiResponse<MangaCharacters?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getMangaCharactersWithHttpInfo(id: kotlin.Int) : ApiResponse<MangaCharacters?> {
        val localVariableConfig = getMangaCharactersRequestConfig(id = id)

        return request<Unit, MangaCharacters>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMangaCharacters
     *
     * @param id
     * @return RequestConfig
     */
    fun getMangaCharactersRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/manga/{id}/characters".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /manga/{id}/external
     *
     *
     * @param id
     * @return ExternalLinks
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMangaExternal(id: kotlin.Int) : ExternalLinks {
        val localVarResponse = getMangaExternalWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ExternalLinks
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /manga/{id}/external
     *
     *
     * @param id
     * @return ApiResponse<ExternalLinks?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getMangaExternalWithHttpInfo(id: kotlin.Int) : ApiResponse<ExternalLinks?> {
        val localVariableConfig = getMangaExternalRequestConfig(id = id)

        return request<Unit, ExternalLinks>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMangaExternal
     *
     * @param id
     * @return RequestConfig
     */
    fun getMangaExternalRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/manga/{id}/external".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /manga/{id}/full
     *
     *
     * @param id
     * @return GetMangaFullById200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMangaFullById(id: kotlin.Int) : GetMangaFullById200Response {
        val localVarResponse = getMangaFullByIdWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetMangaFullById200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /manga/{id}/full
     *
     *
     * @param id
     * @return ApiResponse<GetMangaFullById200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getMangaFullByIdWithHttpInfo(id: kotlin.Int) : ApiResponse<GetMangaFullById200Response?> {
        val localVariableConfig = getMangaFullByIdRequestConfig(id = id)

        return request<Unit, GetMangaFullById200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMangaFullById
     *
     * @param id
     * @return RequestConfig
     */
    fun getMangaFullByIdRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/manga/{id}/full".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /manga/{id}/moreinfo
     *
     *
     * @param id
     * @return Moreinfo
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMangaMoreInfo(id: kotlin.Int) : Moreinfo {
        val localVarResponse = getMangaMoreInfoWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Moreinfo
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /manga/{id}/moreinfo
     *
     *
     * @param id
     * @return ApiResponse<Moreinfo?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getMangaMoreInfoWithHttpInfo(id: kotlin.Int) : ApiResponse<Moreinfo?> {
        val localVariableConfig = getMangaMoreInfoRequestConfig(id = id)

        return request<Unit, Moreinfo>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMangaMoreInfo
     *
     * @param id
     * @return RequestConfig
     */
    fun getMangaMoreInfoRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/manga/{id}/moreinfo".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /manga/{id}/news
     *
     *
     * @param id
     * @param page  (optional)
     * @return MangaNews
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMangaNews(id: kotlin.Int, page: kotlin.Int? = null) : MangaNews {
        val localVarResponse = getMangaNewsWithHttpInfo(id = id, page = page)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MangaNews
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /manga/{id}/news
     *
     *
     * @param id
     * @param page  (optional)
     * @return ApiResponse<MangaNews?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getMangaNewsWithHttpInfo(id: kotlin.Int, page: kotlin.Int?) : ApiResponse<MangaNews?> {
        val localVariableConfig = getMangaNewsRequestConfig(id = id, page = page)

        return request<Unit, MangaNews>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMangaNews
     *
     * @param id
     * @param page  (optional)
     * @return RequestConfig
     */
    fun getMangaNewsRequestConfig(id: kotlin.Int, page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/manga/{id}/news".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /manga/{id}/pictures
     *
     *
     * @param id
     * @return MangaPictures
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMangaPictures(id: kotlin.Int) : MangaPictures {
        val localVarResponse = getMangaPicturesWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MangaPictures
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /manga/{id}/pictures
     *
     *
     * @param id
     * @return ApiResponse<MangaPictures?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getMangaPicturesWithHttpInfo(id: kotlin.Int) : ApiResponse<MangaPictures?> {
        val localVariableConfig = getMangaPicturesRequestConfig(id = id)

        return request<Unit, MangaPictures>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMangaPictures
     *
     * @param id
     * @return RequestConfig
     */
    fun getMangaPicturesRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/manga/{id}/pictures".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /manga/{id}/recommendations
     *
     *
     * @param id
     * @return EntryRecommendations
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMangaRecommendations(id: kotlin.Int) : EntryRecommendations {
        val localVarResponse = getMangaRecommendationsWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EntryRecommendations
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /manga/{id}/recommendations
     *
     *
     * @param id
     * @return ApiResponse<EntryRecommendations?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getMangaRecommendationsWithHttpInfo(id: kotlin.Int) : ApiResponse<EntryRecommendations?> {
        val localVariableConfig = getMangaRecommendationsRequestConfig(id = id)

        return request<Unit, EntryRecommendations>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMangaRecommendations
     *
     * @param id
     * @return RequestConfig
     */
    fun getMangaRecommendationsRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/manga/{id}/recommendations".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /manga/{id}/relations
     *
     *
     * @param id
     * @return GetAnimeRelations200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMangaRelations(id: kotlin.Int) : GetAnimeRelations200Response {
        val localVarResponse = getMangaRelationsWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetAnimeRelations200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /manga/{id}/relations
     *
     *
     * @param id
     * @return ApiResponse<GetAnimeRelations200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getMangaRelationsWithHttpInfo(id: kotlin.Int) : ApiResponse<GetAnimeRelations200Response?> {
        val localVariableConfig = getMangaRelationsRequestConfig(id = id)

        return request<Unit, GetAnimeRelations200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMangaRelations
     *
     * @param id
     * @return RequestConfig
     */
    fun getMangaRelationsRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/manga/{id}/relations".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /manga/{id}/reviews
     *
     *
     * @param id
     * @param page  (optional)
     * @param preliminary Any reviews left during an ongoing anime/manga, those reviews are tagged as preliminary. NOTE: Preliminary reviews are not returned by default so if the entry is airing/publishing you need to add this otherwise you will get an empty list. e.g usage: &#x60;?preliminary&#x3D;true&#x60; (optional)
     * @param spoilers Any reviews that are tagged as a spoiler. Spoiler reviews are not returned by default. e.g usage: &#x60;?spoiler&#x3D;true&#x60; (optional)
     * @return MangaReviews
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMangaReviews(id: kotlin.Int, page: kotlin.Int? = null, preliminary: kotlin.Boolean? = null, spoilers: kotlin.Boolean? = null) : MangaReviews {
        val localVarResponse = getMangaReviewsWithHttpInfo(id = id, page = page, preliminary = preliminary, spoilers = spoilers)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MangaReviews
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /manga/{id}/reviews
     *
     *
     * @param id
     * @param page  (optional)
     * @param preliminary Any reviews left during an ongoing anime/manga, those reviews are tagged as preliminary. NOTE: Preliminary reviews are not returned by default so if the entry is airing/publishing you need to add this otherwise you will get an empty list. e.g usage: &#x60;?preliminary&#x3D;true&#x60; (optional)
     * @param spoilers Any reviews that are tagged as a spoiler. Spoiler reviews are not returned by default. e.g usage: &#x60;?spoiler&#x3D;true&#x60; (optional)
     * @return ApiResponse<MangaReviews?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getMangaReviewsWithHttpInfo(id: kotlin.Int, page: kotlin.Int?, preliminary: kotlin.Boolean?, spoilers: kotlin.Boolean?) : ApiResponse<MangaReviews?> {
        val localVariableConfig = getMangaReviewsRequestConfig(id = id, page = page, preliminary = preliminary, spoilers = spoilers)

        return request<Unit, MangaReviews>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMangaReviews
     *
     * @param id
     * @param page  (optional)
     * @param preliminary Any reviews left during an ongoing anime/manga, those reviews are tagged as preliminary. NOTE: Preliminary reviews are not returned by default so if the entry is airing/publishing you need to add this otherwise you will get an empty list. e.g usage: &#x60;?preliminary&#x3D;true&#x60; (optional)
     * @param spoilers Any reviews that are tagged as a spoiler. Spoiler reviews are not returned by default. e.g usage: &#x60;?spoiler&#x3D;true&#x60; (optional)
     * @return RequestConfig
     */
    fun getMangaReviewsRequestConfig(id: kotlin.Int, page: kotlin.Int?, preliminary: kotlin.Boolean?, spoilers: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (preliminary != null) {
                    put("preliminary", listOf(preliminary.toString()))
                }
                if (spoilers != null) {
                    put("spoilers", listOf(spoilers.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/manga/{id}/reviews".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /manga
     *
     *
     * @param unapproved This is a flag. When supplied it will include entries which are unapproved. Unapproved entries on MyAnimeList are those that are user submitted and have not yet been approved by MAL to show up on other pages. They will have their own specifc pages and are often removed resulting in a 404 error. You do not need to pass a value to it. e.g usage: &#x60;?unapproved&#x60; (optional)
     * @param page  (optional)
     * @param limit  (optional)
     * @param q  (optional)
     * @param type  (optional)
     * @param score  (optional)
     * @param minScore Set a minimum score for results. (optional)
     * @param maxScore Set a maximum score for results (optional)
     * @param status  (optional)
     * @param sfw Filter out Adult entries (optional)
     * @param genres Filter by genre(s) IDs. Can pass multiple with a comma as a delimiter. e.g 1,2,3 (optional)
     * @param genresExclude Exclude genre(s) IDs. Can pass multiple with a comma as a delimiter. e.g 1,2,3 (optional)
     * @param orderBy  (optional)
     * @param sort  (optional)
     * @param letter Return entries starting with the given letter (optional)
     * @param magazines Filter by magazine(s) IDs. Can pass multiple with a comma as a delimiter. e.g 1,2,3 (optional)
     * @param startDate Filter by starting date. Format: YYYY-MM-DD. e.g &#x60;2022&#x60;, &#x60;2005-05&#x60;, &#x60;2005-01-01&#x60; (optional)
     * @param endDate Filter by ending date. Format: YYYY-MM-DD. e.g &#x60;2022&#x60;, &#x60;2005-05&#x60;, &#x60;2005-01-01&#x60; (optional)
     * @return MangaSearch
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMangaSearch(unapproved: kotlin.Boolean? = null, page: kotlin.Int? = null, limit: kotlin.Int? = null, q: kotlin.String? = null, type: MangaSearchQueryType? = null, score: java.math.BigDecimal? = null, minScore: java.math.BigDecimal? = null, maxScore: java.math.BigDecimal? = null, status: MangaSearchQueryStatus? = null, sfw: kotlin.Boolean? = null, genres: kotlin.String? = null, genresExclude: kotlin.String? = null, orderBy: MangaSearchQueryOrderby? = null, sort: SearchQuerySort? = null, letter: kotlin.String? = null, magazines: kotlin.String? = null, startDate: kotlin.String? = null, endDate: kotlin.String? = null) : MangaSearch {
        val localVarResponse = getMangaSearchWithHttpInfo(unapproved = unapproved, page = page, limit = limit, q = q, type = type, score = score, minScore = minScore, maxScore = maxScore, status = status, sfw = sfw, genres = genres, genresExclude = genresExclude, orderBy = orderBy, sort = sort, letter = letter, magazines = magazines, startDate = startDate, endDate = endDate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MangaSearch
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /manga
     *
     *
     * @param unapproved This is a flag. When supplied it will include entries which are unapproved. Unapproved entries on MyAnimeList are those that are user submitted and have not yet been approved by MAL to show up on other pages. They will have their own specifc pages and are often removed resulting in a 404 error. You do not need to pass a value to it. e.g usage: &#x60;?unapproved&#x60; (optional)
     * @param page  (optional)
     * @param limit  (optional)
     * @param q  (optional)
     * @param type  (optional)
     * @param score  (optional)
     * @param minScore Set a minimum score for results. (optional)
     * @param maxScore Set a maximum score for results (optional)
     * @param status  (optional)
     * @param sfw Filter out Adult entries (optional)
     * @param genres Filter by genre(s) IDs. Can pass multiple with a comma as a delimiter. e.g 1,2,3 (optional)
     * @param genresExclude Exclude genre(s) IDs. Can pass multiple with a comma as a delimiter. e.g 1,2,3 (optional)
     * @param orderBy  (optional)
     * @param sort  (optional)
     * @param letter Return entries starting with the given letter (optional)
     * @param magazines Filter by magazine(s) IDs. Can pass multiple with a comma as a delimiter. e.g 1,2,3 (optional)
     * @param startDate Filter by starting date. Format: YYYY-MM-DD. e.g &#x60;2022&#x60;, &#x60;2005-05&#x60;, &#x60;2005-01-01&#x60; (optional)
     * @param endDate Filter by ending date. Format: YYYY-MM-DD. e.g &#x60;2022&#x60;, &#x60;2005-05&#x60;, &#x60;2005-01-01&#x60; (optional)
     * @return ApiResponse<MangaSearch?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getMangaSearchWithHttpInfo(unapproved: kotlin.Boolean?, page: kotlin.Int?, limit: kotlin.Int?, q: kotlin.String?, type: MangaSearchQueryType?, score: java.math.BigDecimal?, minScore: java.math.BigDecimal?, maxScore: java.math.BigDecimal?, status: MangaSearchQueryStatus?, sfw: kotlin.Boolean?, genres: kotlin.String?, genresExclude: kotlin.String?, orderBy: MangaSearchQueryOrderby?, sort: SearchQuerySort?, letter: kotlin.String?, magazines: kotlin.String?, startDate: kotlin.String?, endDate: kotlin.String?) : ApiResponse<MangaSearch?> {
        val localVariableConfig = getMangaSearchRequestConfig(unapproved = unapproved, page = page, limit = limit, q = q, type = type, score = score, minScore = minScore, maxScore = maxScore, status = status, sfw = sfw, genres = genres, genresExclude = genresExclude, orderBy = orderBy, sort = sort, letter = letter, magazines = magazines, startDate = startDate, endDate = endDate)

        return request<Unit, MangaSearch>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMangaSearch
     *
     * @param unapproved This is a flag. When supplied it will include entries which are unapproved. Unapproved entries on MyAnimeList are those that are user submitted and have not yet been approved by MAL to show up on other pages. They will have their own specifc pages and are often removed resulting in a 404 error. You do not need to pass a value to it. e.g usage: &#x60;?unapproved&#x60; (optional)
     * @param page  (optional)
     * @param limit  (optional)
     * @param q  (optional)
     * @param type  (optional)
     * @param score  (optional)
     * @param minScore Set a minimum score for results. (optional)
     * @param maxScore Set a maximum score for results (optional)
     * @param status  (optional)
     * @param sfw Filter out Adult entries (optional)
     * @param genres Filter by genre(s) IDs. Can pass multiple with a comma as a delimiter. e.g 1,2,3 (optional)
     * @param genresExclude Exclude genre(s) IDs. Can pass multiple with a comma as a delimiter. e.g 1,2,3 (optional)
     * @param orderBy  (optional)
     * @param sort  (optional)
     * @param letter Return entries starting with the given letter (optional)
     * @param magazines Filter by magazine(s) IDs. Can pass multiple with a comma as a delimiter. e.g 1,2,3 (optional)
     * @param startDate Filter by starting date. Format: YYYY-MM-DD. e.g &#x60;2022&#x60;, &#x60;2005-05&#x60;, &#x60;2005-01-01&#x60; (optional)
     * @param endDate Filter by ending date. Format: YYYY-MM-DD. e.g &#x60;2022&#x60;, &#x60;2005-05&#x60;, &#x60;2005-01-01&#x60; (optional)
     * @return RequestConfig
     */
    fun getMangaSearchRequestConfig(unapproved: kotlin.Boolean?, page: kotlin.Int?, limit: kotlin.Int?, q: kotlin.String?, type: MangaSearchQueryType?, score: java.math.BigDecimal?, minScore: java.math.BigDecimal?, maxScore: java.math.BigDecimal?, status: MangaSearchQueryStatus?, sfw: kotlin.Boolean?, genres: kotlin.String?, genresExclude: kotlin.String?, orderBy: MangaSearchQueryOrderby?, sort: SearchQuerySort?, letter: kotlin.String?, magazines: kotlin.String?, startDate: kotlin.String?, endDate: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (unapproved != null) {
                    put("unapproved", listOf(unapproved.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (q != null) {
                    put("q", listOf(q.toString()))
                }
                if (type != null) {
                    put("type", listOf(type.toString()))
                }
                if (score != null) {
                    put("score", listOf(score.toString()))
                }
                if (minScore != null) {
                    put("min_score", listOf(minScore.toString()))
                }
                if (maxScore != null) {
                    put("max_score", listOf(maxScore.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (sfw != null) {
                    put("sfw", listOf(sfw.toString()))
                }
                if (genres != null) {
                    put("genres", listOf(genres.toString()))
                }
                if (genresExclude != null) {
                    put("genres_exclude", listOf(genresExclude.toString()))
                }
                if (orderBy != null) {
                    put("order_by", listOf(orderBy.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (letter != null) {
                    put("letter", listOf(letter.toString()))
                }
                if (magazines != null) {
                    put("magazines", listOf(magazines.toString()))
                }
                if (startDate != null) {
                    put("start_date", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("end_date", listOf(endDate.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/manga",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /manga/{id}/statistics
     *
     *
     * @param id
     * @return MangaStatistics
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMangaStatistics(id: kotlin.Int) : MangaStatistics {
        val localVarResponse = getMangaStatisticsWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MangaStatistics
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /manga/{id}/statistics
     *
     *
     * @param id
     * @return ApiResponse<MangaStatistics?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getMangaStatisticsWithHttpInfo(id: kotlin.Int) : ApiResponse<MangaStatistics?> {
        val localVariableConfig = getMangaStatisticsRequestConfig(id = id)

        return request<Unit, MangaStatistics>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMangaStatistics
     *
     * @param id
     * @return RequestConfig
     */
    fun getMangaStatisticsRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/manga/{id}/statistics".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter filter
     */
     enum class FilterGetMangaTopics(val value: kotlin.String) {
         @JsonProperty(value = "all") ALL("all"),
         @JsonProperty(value = "episode") EPISODE("episode"),
         @JsonProperty(value = "other") OTHER("other");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = value
     }

    /**
     * GET /manga/{id}/forum
     *
     *
     * @param id
     * @param filter Filter topics (optional)
     * @return Forum
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMangaTopics(id: kotlin.Int, filter: FilterGetMangaTopics? = null) : Forum {
        val localVarResponse = getMangaTopicsWithHttpInfo(id = id, filter = filter)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Forum
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /manga/{id}/forum
     *
     *
     * @param id
     * @param filter Filter topics (optional)
     * @return ApiResponse<Forum?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getMangaTopicsWithHttpInfo(id: kotlin.Int, filter: FilterGetMangaTopics?) : ApiResponse<Forum?> {
        val localVariableConfig = getMangaTopicsRequestConfig(id = id, filter = filter)

        return request<Unit, Forum>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMangaTopics
     *
     * @param id
     * @param filter Filter topics (optional)
     * @return RequestConfig
     */
    fun getMangaTopicsRequestConfig(id: kotlin.Int, filter: FilterGetMangaTopics?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filter != null) {
                    put("filter", listOf(filter.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/manga/{id}/forum".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /manga/{id}/userupdates
     *
     *
     * @param id
     * @param page  (optional)
     * @return MangaUserupdates
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMangaUserUpdates(id: kotlin.Int, page: kotlin.Int? = null) : MangaUserupdates {
        val localVarResponse = getMangaUserUpdatesWithHttpInfo(id = id, page = page)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MangaUserupdates
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /manga/{id}/userupdates
     *
     *
     * @param id
     * @param page  (optional)
     * @return ApiResponse<MangaUserupdates?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getMangaUserUpdatesWithHttpInfo(id: kotlin.Int, page: kotlin.Int?) : ApiResponse<MangaUserupdates?> {
        val localVariableConfig = getMangaUserUpdatesRequestConfig(id = id, page = page)

        return request<Unit, MangaUserupdates>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMangaUserUpdates
     *
     * @param id
     * @param page  (optional)
     * @return RequestConfig
     */
    fun getMangaUserUpdatesRequestConfig(id: kotlin.Int, page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/manga/{id}/userupdates".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
