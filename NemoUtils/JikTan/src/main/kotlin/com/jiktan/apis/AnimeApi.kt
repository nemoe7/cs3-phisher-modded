/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.jiktan.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import com.jiktan.models.AnimeCharacters
import com.jiktan.models.AnimeEpisodes
import com.jiktan.models.AnimeNews
import com.jiktan.models.AnimeReviews
import com.jiktan.models.AnimeSearch
import com.jiktan.models.AnimeSearchQueryOrderby
import com.jiktan.models.AnimeSearchQueryRating
import com.jiktan.models.AnimeSearchQueryStatus
import com.jiktan.models.AnimeSearchQueryType
import com.jiktan.models.AnimeStaff
import com.jiktan.models.AnimeStatistics
import com.jiktan.models.AnimeThemes
import com.jiktan.models.AnimeUserupdates
import com.jiktan.models.AnimeVideos
import com.jiktan.models.AnimeVideosEpisodes
import com.jiktan.models.EntryRecommendations
import com.jiktan.models.ExternalLinks
import com.jiktan.models.Forum
import com.jiktan.models.GetAnimeById200Response
import com.jiktan.models.GetAnimeEpisodeById200Response
import com.jiktan.models.GetAnimeFullById200Response
import com.jiktan.models.GetAnimeRelations200Response
import com.jiktan.models.Moreinfo
import com.jiktan.models.PicturesVariants
import com.jiktan.models.SearchQuerySort

import com.fasterxml.jackson.annotation.JsonProperty

import com.jiktan.infrastructure.ApiClient
import com.jiktan.infrastructure.ApiResponse
import com.jiktan.infrastructure.ClientException
import com.jiktan.infrastructure.ClientError
import com.jiktan.infrastructure.ServerException
import com.jiktan.infrastructure.ServerError
import com.jiktan.infrastructure.MultiValueMap
import com.jiktan.infrastructure.PartConfig
import com.jiktan.infrastructure.RequestConfig
import com.jiktan.infrastructure.RequestMethod
import com.jiktan.infrastructure.ResponseType
import com.jiktan.infrastructure.Success
import com.jiktan.infrastructure.toMultiValue

class AnimeApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.jikan.moe/v4")
        }
    }

    /**
     * GET /anime/{id}
     *
     *
     * @param id
     * @return GetAnimeById200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAnimeById(id: kotlin.Int) : GetAnimeById200Response {
        val localVarResponse = getAnimeByIdWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetAnimeById200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /anime/{id}
     *
     *
     * @param id
     * @return ApiResponse<GetAnimeById200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getAnimeByIdWithHttpInfo(id: kotlin.Int) : ApiResponse<GetAnimeById200Response?> {
        val localVariableConfig = getAnimeByIdRequestConfig(id = id)

        return request<Unit, GetAnimeById200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAnimeById
     *
     * @param id
     * @return RequestConfig
     */
    fun getAnimeByIdRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/anime/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /anime/{id}/characters
     *
     *
     * @param id
     * @return AnimeCharacters
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAnimeCharacters(id: kotlin.Int) : AnimeCharacters {
        val localVarResponse = getAnimeCharactersWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AnimeCharacters
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /anime/{id}/characters
     *
     *
     * @param id
     * @return ApiResponse<AnimeCharacters?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getAnimeCharactersWithHttpInfo(id: kotlin.Int) : ApiResponse<AnimeCharacters?> {
        val localVariableConfig = getAnimeCharactersRequestConfig(id = id)

        return request<Unit, AnimeCharacters>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAnimeCharacters
     *
     * @param id
     * @return RequestConfig
     */
    fun getAnimeCharactersRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/anime/{id}/characters".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /anime/{id}/episodes/{episode}
     *
     *
     * @param id
     * @param episode
     * @return GetAnimeEpisodeById200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAnimeEpisodeById(id: kotlin.Int, episode: kotlin.Int) : GetAnimeEpisodeById200Response {
        val localVarResponse = getAnimeEpisodeByIdWithHttpInfo(id = id, episode = episode)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetAnimeEpisodeById200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /anime/{id}/episodes/{episode}
     *
     *
     * @param id
     * @param episode
     * @return ApiResponse<GetAnimeEpisodeById200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getAnimeEpisodeByIdWithHttpInfo(id: kotlin.Int, episode: kotlin.Int) : ApiResponse<GetAnimeEpisodeById200Response?> {
        val localVariableConfig = getAnimeEpisodeByIdRequestConfig(id = id, episode = episode)

        return request<Unit, GetAnimeEpisodeById200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAnimeEpisodeById
     *
     * @param id
     * @param episode
     * @return RequestConfig
     */
    fun getAnimeEpisodeByIdRequestConfig(id: kotlin.Int, episode: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/anime/{id}/episodes/{episode}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"episode"+"}", encodeURIComponent(episode.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /anime/{id}/episodes
     *
     *
     * @param id
     * @param page  (optional)
     * @return AnimeEpisodes
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAnimeEpisodes(id: kotlin.Int, page: kotlin.Int? = null) : AnimeEpisodes {
        val localVarResponse = getAnimeEpisodesWithHttpInfo(id = id, page = page)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AnimeEpisodes
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /anime/{id}/episodes
     *
     *
     * @param id
     * @param page  (optional)
     * @return ApiResponse<AnimeEpisodes?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getAnimeEpisodesWithHttpInfo(id: kotlin.Int, page: kotlin.Int?) : ApiResponse<AnimeEpisodes?> {
        val localVariableConfig = getAnimeEpisodesRequestConfig(id = id, page = page)

        return request<Unit, AnimeEpisodes>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAnimeEpisodes
     *
     * @param id
     * @param page  (optional)
     * @return RequestConfig
     */
    fun getAnimeEpisodesRequestConfig(id: kotlin.Int, page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/anime/{id}/episodes".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /anime/{id}/external
     *
     *
     * @param id
     * @return ExternalLinks
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAnimeExternal(id: kotlin.Int) : ExternalLinks {
        val localVarResponse = getAnimeExternalWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ExternalLinks
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /anime/{id}/external
     *
     *
     * @param id
     * @return ApiResponse<ExternalLinks?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getAnimeExternalWithHttpInfo(id: kotlin.Int) : ApiResponse<ExternalLinks?> {
        val localVariableConfig = getAnimeExternalRequestConfig(id = id)

        return request<Unit, ExternalLinks>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAnimeExternal
     *
     * @param id
     * @return RequestConfig
     */
    fun getAnimeExternalRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/anime/{id}/external".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter filter
     */
     enum class FilterGetAnimeForum(val value: kotlin.String) {
         @JsonProperty(value = "all") ALL("all"),
         @JsonProperty(value = "episode") EPISODE("episode"),
         @JsonProperty(value = "other") OTHER("other");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = value
     }

    /**
     * GET /anime/{id}/forum
     *
     *
     * @param id
     * @param filter Filter topics (optional)
     * @return Forum
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAnimeForum(id: kotlin.Int, filter: FilterGetAnimeForum? = null) : Forum {
        val localVarResponse = getAnimeForumWithHttpInfo(id = id, filter = filter)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Forum
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /anime/{id}/forum
     *
     *
     * @param id
     * @param filter Filter topics (optional)
     * @return ApiResponse<Forum?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getAnimeForumWithHttpInfo(id: kotlin.Int, filter: FilterGetAnimeForum?) : ApiResponse<Forum?> {
        val localVariableConfig = getAnimeForumRequestConfig(id = id, filter = filter)

        return request<Unit, Forum>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAnimeForum
     *
     * @param id
     * @param filter Filter topics (optional)
     * @return RequestConfig
     */
    fun getAnimeForumRequestConfig(id: kotlin.Int, filter: FilterGetAnimeForum?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filter != null) {
                    put("filter", listOf(filter.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/anime/{id}/forum".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /anime/{id}/full
     *
     *
     * @param id
     * @return GetAnimeFullById200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAnimeFullById(id: kotlin.Int) : GetAnimeFullById200Response {
        val localVarResponse = getAnimeFullByIdWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetAnimeFullById200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /anime/{id}/full
     *
     *
     * @param id
     * @return ApiResponse<GetAnimeFullById200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getAnimeFullByIdWithHttpInfo(id: kotlin.Int) : ApiResponse<GetAnimeFullById200Response?> {
        val localVariableConfig = getAnimeFullByIdRequestConfig(id = id)

        return request<Unit, GetAnimeFullById200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAnimeFullById
     *
     * @param id
     * @return RequestConfig
     */
    fun getAnimeFullByIdRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/anime/{id}/full".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /anime/{id}/moreinfo
     *
     *
     * @param id
     * @return Moreinfo
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAnimeMoreInfo(id: kotlin.Int) : Moreinfo {
        val localVarResponse = getAnimeMoreInfoWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Moreinfo
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /anime/{id}/moreinfo
     *
     *
     * @param id
     * @return ApiResponse<Moreinfo?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getAnimeMoreInfoWithHttpInfo(id: kotlin.Int) : ApiResponse<Moreinfo?> {
        val localVariableConfig = getAnimeMoreInfoRequestConfig(id = id)

        return request<Unit, Moreinfo>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAnimeMoreInfo
     *
     * @param id
     * @return RequestConfig
     */
    fun getAnimeMoreInfoRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/anime/{id}/moreinfo".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /anime/{id}/news
     *
     *
     * @param id
     * @param page  (optional)
     * @return AnimeNews
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAnimeNews(id: kotlin.Int, page: kotlin.Int? = null) : AnimeNews {
        val localVarResponse = getAnimeNewsWithHttpInfo(id = id, page = page)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AnimeNews
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /anime/{id}/news
     *
     *
     * @param id
     * @param page  (optional)
     * @return ApiResponse<AnimeNews?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getAnimeNewsWithHttpInfo(id: kotlin.Int, page: kotlin.Int?) : ApiResponse<AnimeNews?> {
        val localVariableConfig = getAnimeNewsRequestConfig(id = id, page = page)

        return request<Unit, AnimeNews>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAnimeNews
     *
     * @param id
     * @param page  (optional)
     * @return RequestConfig
     */
    fun getAnimeNewsRequestConfig(id: kotlin.Int, page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/anime/{id}/news".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /anime/{id}/pictures
     *
     *
     * @param id
     * @return PicturesVariants
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAnimePictures(id: kotlin.Int) : PicturesVariants {
        val localVarResponse = getAnimePicturesWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PicturesVariants
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /anime/{id}/pictures
     *
     *
     * @param id
     * @return ApiResponse<PicturesVariants?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getAnimePicturesWithHttpInfo(id: kotlin.Int) : ApiResponse<PicturesVariants?> {
        val localVariableConfig = getAnimePicturesRequestConfig(id = id)

        return request<Unit, PicturesVariants>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAnimePictures
     *
     * @param id
     * @return RequestConfig
     */
    fun getAnimePicturesRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/anime/{id}/pictures".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /anime/{id}/recommendations
     *
     *
     * @param id
     * @return EntryRecommendations
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAnimeRecommendations(id: kotlin.Int) : EntryRecommendations {
        val localVarResponse = getAnimeRecommendationsWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EntryRecommendations
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /anime/{id}/recommendations
     *
     *
     * @param id
     * @return ApiResponse<EntryRecommendations?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getAnimeRecommendationsWithHttpInfo(id: kotlin.Int) : ApiResponse<EntryRecommendations?> {
        val localVariableConfig = getAnimeRecommendationsRequestConfig(id = id)

        return request<Unit, EntryRecommendations>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAnimeRecommendations
     *
     * @param id
     * @return RequestConfig
     */
    fun getAnimeRecommendationsRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/anime/{id}/recommendations".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /anime/{id}/relations
     *
     *
     * @param id
     * @return GetAnimeRelations200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAnimeRelations(id: kotlin.Int) : GetAnimeRelations200Response {
        val localVarResponse = getAnimeRelationsWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetAnimeRelations200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /anime/{id}/relations
     *
     *
     * @param id
     * @return ApiResponse<GetAnimeRelations200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getAnimeRelationsWithHttpInfo(id: kotlin.Int) : ApiResponse<GetAnimeRelations200Response?> {
        val localVariableConfig = getAnimeRelationsRequestConfig(id = id)

        return request<Unit, GetAnimeRelations200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAnimeRelations
     *
     * @param id
     * @return RequestConfig
     */
    fun getAnimeRelationsRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/anime/{id}/relations".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /anime/{id}/reviews
     *
     *
     * @param id
     * @param page  (optional)
     * @param preliminary Any reviews left during an ongoing anime/manga, those reviews are tagged as preliminary. NOTE: Preliminary reviews are not returned by default so if the entry is airing/publishing you need to add this otherwise you will get an empty list. e.g usage: &#x60;?preliminary&#x3D;true&#x60; (optional)
     * @param spoilers Any reviews that are tagged as a spoiler. Spoiler reviews are not returned by default. e.g usage: &#x60;?spoiler&#x3D;true&#x60; (optional)
     * @return AnimeReviews
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAnimeReviews(id: kotlin.Int, page: kotlin.Int? = null, preliminary: kotlin.Boolean? = null, spoilers: kotlin.Boolean? = null) : AnimeReviews {
        val localVarResponse = getAnimeReviewsWithHttpInfo(id = id, page = page, preliminary = preliminary, spoilers = spoilers)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AnimeReviews
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /anime/{id}/reviews
     *
     *
     * @param id
     * @param page  (optional)
     * @param preliminary Any reviews left during an ongoing anime/manga, those reviews are tagged as preliminary. NOTE: Preliminary reviews are not returned by default so if the entry is airing/publishing you need to add this otherwise you will get an empty list. e.g usage: &#x60;?preliminary&#x3D;true&#x60; (optional)
     * @param spoilers Any reviews that are tagged as a spoiler. Spoiler reviews are not returned by default. e.g usage: &#x60;?spoiler&#x3D;true&#x60; (optional)
     * @return ApiResponse<AnimeReviews?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getAnimeReviewsWithHttpInfo(id: kotlin.Int, page: kotlin.Int?, preliminary: kotlin.Boolean?, spoilers: kotlin.Boolean?) : ApiResponse<AnimeReviews?> {
        val localVariableConfig = getAnimeReviewsRequestConfig(id = id, page = page, preliminary = preliminary, spoilers = spoilers)

        return request<Unit, AnimeReviews>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAnimeReviews
     *
     * @param id
     * @param page  (optional)
     * @param preliminary Any reviews left during an ongoing anime/manga, those reviews are tagged as preliminary. NOTE: Preliminary reviews are not returned by default so if the entry is airing/publishing you need to add this otherwise you will get an empty list. e.g usage: &#x60;?preliminary&#x3D;true&#x60; (optional)
     * @param spoilers Any reviews that are tagged as a spoiler. Spoiler reviews are not returned by default. e.g usage: &#x60;?spoiler&#x3D;true&#x60; (optional)
     * @return RequestConfig
     */
    fun getAnimeReviewsRequestConfig(id: kotlin.Int, page: kotlin.Int?, preliminary: kotlin.Boolean?, spoilers: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (preliminary != null) {
                    put("preliminary", listOf(preliminary.toString()))
                }
                if (spoilers != null) {
                    put("spoilers", listOf(spoilers.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/anime/{id}/reviews".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /anime
     *
     *
     * @param unapproved This is a flag. When supplied it will include entries which are unapproved. Unapproved entries on MyAnimeList are those that are user submitted and have not yet been approved by MAL to show up on other pages. They will have their own specifc pages and are often removed resulting in a 404 error. You do not need to pass a value to it. e.g usage: &#x60;?unapproved&#x60; (optional)
     * @param page  (optional)
     * @param limit  (optional)
     * @param q  (optional)
     * @param type  (optional)
     * @param score  (optional)
     * @param minScore Set a minimum score for results. (optional)
     * @param maxScore Set a maximum score for results (optional)
     * @param status  (optional)
     * @param rating  (optional)
     * @param sfw Filter out Adult entries (optional)
     * @param genres Filter by genre(s) IDs. Can pass multiple with a comma as a delimiter. e.g 1,2,3 (optional)
     * @param genresExclude Exclude genre(s) IDs. Can pass multiple with a comma as a delimiter. e.g 1,2,3 (optional)
     * @param orderBy  (optional)
     * @param sort  (optional)
     * @param letter Return entries starting with the given letter (optional)
     * @param producers Filter by producer(s) IDs. Can pass multiple with a comma as a delimiter. e.g 1,2,3 (optional)
     * @param startDate Filter by starting date. Format: YYYY-MM-DD. e.g &#x60;2022&#x60;, &#x60;2005-05&#x60;, &#x60;2005-01-01&#x60; (optional)
     * @param endDate Filter by ending date. Format: YYYY-MM-DD. e.g &#x60;2022&#x60;, &#x60;2005-05&#x60;, &#x60;2005-01-01&#x60; (optional)
     * @return AnimeSearch
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAnimeSearch(unapproved: kotlin.Boolean? = null, page: kotlin.Int? = null, limit: kotlin.Int? = null, q: kotlin.String? = null, type: AnimeSearchQueryType? = null, score: java.math.BigDecimal? = null, minScore: java.math.BigDecimal? = null, maxScore: java.math.BigDecimal? = null, status: AnimeSearchQueryStatus? = null, rating: AnimeSearchQueryRating? = null, sfw: kotlin.Boolean? = null, genres: kotlin.String? = null, genresExclude: kotlin.String? = null, orderBy: AnimeSearchQueryOrderby? = null, sort: SearchQuerySort? = null, letter: kotlin.String? = null, producers: kotlin.String? = null, startDate: kotlin.String? = null, endDate: kotlin.String? = null) : AnimeSearch {
        val localVarResponse = getAnimeSearchWithHttpInfo(unapproved = unapproved, page = page, limit = limit, q = q, type = type, score = score, minScore = minScore, maxScore = maxScore, status = status, rating = rating, sfw = sfw, genres = genres, genresExclude = genresExclude, orderBy = orderBy, sort = sort, letter = letter, producers = producers, startDate = startDate, endDate = endDate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AnimeSearch
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /anime
     *
     *
     * @param unapproved This is a flag. When supplied it will include entries which are unapproved. Unapproved entries on MyAnimeList are those that are user submitted and have not yet been approved by MAL to show up on other pages. They will have their own specifc pages and are often removed resulting in a 404 error. You do not need to pass a value to it. e.g usage: &#x60;?unapproved&#x60; (optional)
     * @param page  (optional)
     * @param limit  (optional)
     * @param q  (optional)
     * @param type  (optional)
     * @param score  (optional)
     * @param minScore Set a minimum score for results. (optional)
     * @param maxScore Set a maximum score for results (optional)
     * @param status  (optional)
     * @param rating  (optional)
     * @param sfw Filter out Adult entries (optional)
     * @param genres Filter by genre(s) IDs. Can pass multiple with a comma as a delimiter. e.g 1,2,3 (optional)
     * @param genresExclude Exclude genre(s) IDs. Can pass multiple with a comma as a delimiter. e.g 1,2,3 (optional)
     * @param orderBy  (optional)
     * @param sort  (optional)
     * @param letter Return entries starting with the given letter (optional)
     * @param producers Filter by producer(s) IDs. Can pass multiple with a comma as a delimiter. e.g 1,2,3 (optional)
     * @param startDate Filter by starting date. Format: YYYY-MM-DD. e.g &#x60;2022&#x60;, &#x60;2005-05&#x60;, &#x60;2005-01-01&#x60; (optional)
     * @param endDate Filter by ending date. Format: YYYY-MM-DD. e.g &#x60;2022&#x60;, &#x60;2005-05&#x60;, &#x60;2005-01-01&#x60; (optional)
     * @return ApiResponse<AnimeSearch?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getAnimeSearchWithHttpInfo(unapproved: kotlin.Boolean?, page: kotlin.Int?, limit: kotlin.Int?, q: kotlin.String?, type: AnimeSearchQueryType?, score: java.math.BigDecimal?, minScore: java.math.BigDecimal?, maxScore: java.math.BigDecimal?, status: AnimeSearchQueryStatus?, rating: AnimeSearchQueryRating?, sfw: kotlin.Boolean?, genres: kotlin.String?, genresExclude: kotlin.String?, orderBy: AnimeSearchQueryOrderby?, sort: SearchQuerySort?, letter: kotlin.String?, producers: kotlin.String?, startDate: kotlin.String?, endDate: kotlin.String?) : ApiResponse<AnimeSearch?> {
        val localVariableConfig = getAnimeSearchRequestConfig(unapproved = unapproved, page = page, limit = limit, q = q, type = type, score = score, minScore = minScore, maxScore = maxScore, status = status, rating = rating, sfw = sfw, genres = genres, genresExclude = genresExclude, orderBy = orderBy, sort = sort, letter = letter, producers = producers, startDate = startDate, endDate = endDate)

        return request<Unit, AnimeSearch>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAnimeSearch
     *
     * @param unapproved This is a flag. When supplied it will include entries which are unapproved. Unapproved entries on MyAnimeList are those that are user submitted and have not yet been approved by MAL to show up on other pages. They will have their own specifc pages and are often removed resulting in a 404 error. You do not need to pass a value to it. e.g usage: &#x60;?unapproved&#x60; (optional)
     * @param page  (optional)
     * @param limit  (optional)
     * @param q  (optional)
     * @param type  (optional)
     * @param score  (optional)
     * @param minScore Set a minimum score for results. (optional)
     * @param maxScore Set a maximum score for results (optional)
     * @param status  (optional)
     * @param rating  (optional)
     * @param sfw Filter out Adult entries (optional)
     * @param genres Filter by genre(s) IDs. Can pass multiple with a comma as a delimiter. e.g 1,2,3 (optional)
     * @param genresExclude Exclude genre(s) IDs. Can pass multiple with a comma as a delimiter. e.g 1,2,3 (optional)
     * @param orderBy  (optional)
     * @param sort  (optional)
     * @param letter Return entries starting with the given letter (optional)
     * @param producers Filter by producer(s) IDs. Can pass multiple with a comma as a delimiter. e.g 1,2,3 (optional)
     * @param startDate Filter by starting date. Format: YYYY-MM-DD. e.g &#x60;2022&#x60;, &#x60;2005-05&#x60;, &#x60;2005-01-01&#x60; (optional)
     * @param endDate Filter by ending date. Format: YYYY-MM-DD. e.g &#x60;2022&#x60;, &#x60;2005-05&#x60;, &#x60;2005-01-01&#x60; (optional)
     * @return RequestConfig
     */
    fun getAnimeSearchRequestConfig(unapproved: kotlin.Boolean?, page: kotlin.Int?, limit: kotlin.Int?, q: kotlin.String?, type: AnimeSearchQueryType?, score: java.math.BigDecimal?, minScore: java.math.BigDecimal?, maxScore: java.math.BigDecimal?, status: AnimeSearchQueryStatus?, rating: AnimeSearchQueryRating?, sfw: kotlin.Boolean?, genres: kotlin.String?, genresExclude: kotlin.String?, orderBy: AnimeSearchQueryOrderby?, sort: SearchQuerySort?, letter: kotlin.String?, producers: kotlin.String?, startDate: kotlin.String?, endDate: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (unapproved != null) {
                    put("unapproved", listOf(unapproved.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (q != null) {
                    put("q", listOf(q.toString()))
                }
                if (type != null) {
                    put("type", listOf(type.toString()))
                }
                if (score != null) {
                    put("score", listOf(score.toString()))
                }
                if (minScore != null) {
                    put("min_score", listOf(minScore.toString()))
                }
                if (maxScore != null) {
                    put("max_score", listOf(maxScore.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (rating != null) {
                    put("rating", listOf(rating.toString()))
                }
                if (sfw != null) {
                    put("sfw", listOf(sfw.toString()))
                }
                if (genres != null) {
                    put("genres", listOf(genres.toString()))
                }
                if (genresExclude != null) {
                    put("genres_exclude", listOf(genresExclude.toString()))
                }
                if (orderBy != null) {
                    put("order_by", listOf(orderBy.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (letter != null) {
                    put("letter", listOf(letter.toString()))
                }
                if (producers != null) {
                    put("producers", listOf(producers.toString()))
                }
                if (startDate != null) {
                    put("start_date", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("end_date", listOf(endDate.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/anime",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /anime/{id}/staff
     *
     *
     * @param id
     * @return AnimeStaff
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAnimeStaff(id: kotlin.Int) : AnimeStaff {
        val localVarResponse = getAnimeStaffWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AnimeStaff
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /anime/{id}/staff
     *
     *
     * @param id
     * @return ApiResponse<AnimeStaff?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getAnimeStaffWithHttpInfo(id: kotlin.Int) : ApiResponse<AnimeStaff?> {
        val localVariableConfig = getAnimeStaffRequestConfig(id = id)

        return request<Unit, AnimeStaff>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAnimeStaff
     *
     * @param id
     * @return RequestConfig
     */
    fun getAnimeStaffRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/anime/{id}/staff".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /anime/{id}/statistics
     *
     *
     * @param id
     * @return AnimeStatistics
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAnimeStatistics(id: kotlin.Int) : AnimeStatistics {
        val localVarResponse = getAnimeStatisticsWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AnimeStatistics
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /anime/{id}/statistics
     *
     *
     * @param id
     * @return ApiResponse<AnimeStatistics?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getAnimeStatisticsWithHttpInfo(id: kotlin.Int) : ApiResponse<AnimeStatistics?> {
        val localVariableConfig = getAnimeStatisticsRequestConfig(id = id)

        return request<Unit, AnimeStatistics>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAnimeStatistics
     *
     * @param id
     * @return RequestConfig
     */
    fun getAnimeStatisticsRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/anime/{id}/statistics".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /anime/{id}/streaming
     *
     *
     * @param id
     * @return ExternalLinks
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAnimeStreaming(id: kotlin.Int) : ExternalLinks {
        val localVarResponse = getAnimeStreamingWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ExternalLinks
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /anime/{id}/streaming
     *
     *
     * @param id
     * @return ApiResponse<ExternalLinks?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getAnimeStreamingWithHttpInfo(id: kotlin.Int) : ApiResponse<ExternalLinks?> {
        val localVariableConfig = getAnimeStreamingRequestConfig(id = id)

        return request<Unit, ExternalLinks>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAnimeStreaming
     *
     * @param id
     * @return RequestConfig
     */
    fun getAnimeStreamingRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/anime/{id}/streaming".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /anime/{id}/themes
     *
     *
     * @param id
     * @return AnimeThemes
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAnimeThemes(id: kotlin.Int) : AnimeThemes {
        val localVarResponse = getAnimeThemesWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AnimeThemes
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /anime/{id}/themes
     *
     *
     * @param id
     * @return ApiResponse<AnimeThemes?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getAnimeThemesWithHttpInfo(id: kotlin.Int) : ApiResponse<AnimeThemes?> {
        val localVariableConfig = getAnimeThemesRequestConfig(id = id)

        return request<Unit, AnimeThemes>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAnimeThemes
     *
     * @param id
     * @return RequestConfig
     */
    fun getAnimeThemesRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/anime/{id}/themes".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /anime/{id}/userupdates
     *
     *
     * @param id
     * @param page  (optional)
     * @return AnimeUserupdates
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAnimeUserUpdates(id: kotlin.Int, page: kotlin.Int? = null) : AnimeUserupdates {
        val localVarResponse = getAnimeUserUpdatesWithHttpInfo(id = id, page = page)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AnimeUserupdates
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /anime/{id}/userupdates
     *
     *
     * @param id
     * @param page  (optional)
     * @return ApiResponse<AnimeUserupdates?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getAnimeUserUpdatesWithHttpInfo(id: kotlin.Int, page: kotlin.Int?) : ApiResponse<AnimeUserupdates?> {
        val localVariableConfig = getAnimeUserUpdatesRequestConfig(id = id, page = page)

        return request<Unit, AnimeUserupdates>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAnimeUserUpdates
     *
     * @param id
     * @param page  (optional)
     * @return RequestConfig
     */
    fun getAnimeUserUpdatesRequestConfig(id: kotlin.Int, page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/anime/{id}/userupdates".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /anime/{id}/videos
     *
     *
     * @param id
     * @return AnimeVideos
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAnimeVideos(id: kotlin.Int) : AnimeVideos {
        val localVarResponse = getAnimeVideosWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AnimeVideos
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /anime/{id}/videos
     *
     *
     * @param id
     * @return ApiResponse<AnimeVideos?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getAnimeVideosWithHttpInfo(id: kotlin.Int) : ApiResponse<AnimeVideos?> {
        val localVariableConfig = getAnimeVideosRequestConfig(id = id)

        return request<Unit, AnimeVideos>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAnimeVideos
     *
     * @param id
     * @return RequestConfig
     */
    fun getAnimeVideosRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/anime/{id}/videos".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /anime/{id}/videos/episodes
     *
     *
     * @param id
     * @param page  (optional)
     * @return AnimeVideosEpisodes
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAnimeVideosEpisodes(id: kotlin.Int, page: kotlin.Int? = null) : AnimeVideosEpisodes {
        val localVarResponse = getAnimeVideosEpisodesWithHttpInfo(id = id, page = page)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AnimeVideosEpisodes
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /anime/{id}/videos/episodes
     *
     *
     * @param id
     * @param page  (optional)
     * @return ApiResponse<AnimeVideosEpisodes?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getAnimeVideosEpisodesWithHttpInfo(id: kotlin.Int, page: kotlin.Int?) : ApiResponse<AnimeVideosEpisodes?> {
        val localVariableConfig = getAnimeVideosEpisodesRequestConfig(id = id, page = page)

        return request<Unit, AnimeVideosEpisodes>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAnimeVideosEpisodes
     *
     * @param id
     * @param page  (optional)
     * @return RequestConfig
     */
    fun getAnimeVideosEpisodesRequestConfig(id: kotlin.Int, page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/anime/{id}/videos/episodes".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
